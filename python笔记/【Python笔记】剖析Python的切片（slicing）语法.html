<html>
<head>
  <title>【Python笔记】剖析Python的切片（slicing）语法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="781"/>
<h1>【Python笔记】剖析Python的切片（slicing）语法</h1>

<div>
<span><div><br/></div><div><span style="font-size:14px"><strong>扩展切片（extended_slicing）</strong></span></div><div><br/></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 21px;">s[begin : end : stride]   begin :开始位置，end：结束位置  stride： 英文资料中通常称为&quot;stride&quot;或&quot;step&quot;  就是跳跃的两个字符见的空隙的数量，它的正负也决定着切片的方向 整数代表着从左往右    负数代表着从右往左  但不管刚想如何，开始切片的时候开始位置的字符一定会被切走，等于切片得到的字符的开始位置的字符就是我们切片开始的位置的字符。</span></span></div><div><br/></div><div><br/></div><div><span style="font-size:14px">相信即使是Python新手也很容易理解下面的切片行为：<br/></span><div><div><b>[python]</b> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="view plain">view plain</a> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="copy">copy</a></div><ol start="1"><li>&gt;&gt;&gt; s = 'this_is_a_test'  </li><li>&gt;&gt;&gt; s[1 : 5]  </li><li>'his_'  </li></ol></div>
进一步，下面的语法及输出也很不难理解：<br/><div><div><b>[python]</b> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="view plain">view plain</a> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="copy">copy</a></div><ol start="1"><li>&gt;&gt;&gt; s = 'this_is_a_test'  </li><li>&gt;&gt;&gt; s[ : : 2]  </li><li>'ti_sats'  </li></ol></div>
那么，下面的呢？<br/><div><div><b>[python]</b> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="view plain">view plain</a> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="copy">copy</a></div><ol start="1"><li>&gt;&gt;&gt; s = 'this_is_a_test'  </li><li>&gt;&gt;&gt; s[ : : -1]  </li><li>'tset_a_si_siht'  ## 为何s被反转了？  </li><li>&gt;&gt;&gt; s[1 : 6 : -1]  </li><li>''  ## 为何只得到个空串？  </li><li>&gt;&gt;&gt; s[6 : 1 : -1]    </li><li>'si_si'  ## 为何是这个结果？  </li></ol></div>
是不是觉得当slicing表达式的第3个参数（步长，&quot;stride&quot; or &quot;step&quot;）为负数时，结果有点奇怪？<br/>
说实话，新手对上述结果感到困惑是正常的（当然，如果你完全搞明白了“为什么”，那么恭喜你，因为你对Python语法基础掌握的应该比较扎实了）。<br/>
本篇笔记就是要剖析slicing表达式的语法，争取为Python初学者解开上例的困惑。<br/><p><span style="font-size:14px"><strong>1. 切片表达式（slicing expression）<br/></strong></span><span style="font-size:14px"><a href="http://lib.csdn.net/base/python" style="color:#df3434; font-weight:bold;" target="_blank" title="Python知识库">Python</a><a href="https://docs.python.org/2/reference/expressions.html#slicings" target="_blank">官方文档</a>对切片语法的说明非常简洁：<br/></span><span style="font-size:14px">A slicing selects a range of items in a sequence object (e.g., a string, tuple or list). Slicings may be used as expressions or as targets in assignment or del statements.<br/></span><span style="font-size:14px">根据文档说明，切片语法分为两种：<strong>简单切片（simple_slicing）</strong>和<strong>扩展切片（extended_slicing）</strong>，下面分别进行介绍。</span></p><span style="font-size:14px"><strong>2. 简单切片（simple_slicing）</strong><br/>
简单切片语法如下：<br/>
s[begin : end]<br/>
其中，s表示任何<a href="https://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange" target="_blank">sequence类型</a>的 对象，begin和end必须是int值或求值后可以得到int值的表达式，它们及其之间的分号共同构成了一个前闭后开区间（即begin &lt;= idx &lt; end），指明切片操作将要访问的源序列s的索引值的begin和end，其中真正的end位置是s中end的前一个位置，也即，切片返回的序列的最后一 个element在源序列s的索引为(end-1)。<br/><strong>备注1：</strong>begin和end都可以被缺省，此时，它们的默认值分别是0和sys.maxint<br/><strong>备注2：</strong>begin和end的值可以超过序列的实际长度，如s = [1, 2, 3]; s[0 : 8]也是合法的<br/><strong>备注3：</strong>begin和end均可以为负值。按照Python解释器内部实现的约定，-1是序列s最后一个元素的索引，-2是倒数第二个元素的索引，以此类推。我们可以借助Python官方教程<a href="https://docs.python.org/2/tutorial/introduction.html#strings" target="_blank">strings说明文档</a>关于slice的部分来理解正/负索引号的对应关系（<span style="background-color:rgb(255,255,0)">注意</span>，下面的示意图对原文档中索引值画的位置有所微调，个人认为这样更易于大多数人的理解）：<br/><img src="【Python笔记】剖析Python的切片（slicing）语法_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg"/><br/>
由上图可知，<span style="background-color:rgb(255,255,0)"><strong>Python内部表示sequence类型时，若采用正索引值表示，则有效的索引范围是[0, len(s)-1]；若采用负索引值表示，则有效的索引范围是[-len(s), -1]</strong></span>。<br/>
如果能牢牢记住这一点，那关于slice的一些看起来让人疑惑的语法行为就比较容易理解了。<br/>
下面的slicing表达式均属于简单切片语法：<br/></span><div><div><b>[python]</b> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="view plain">view plain</a> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="copy">copy</a></div><ol start="1"><li>&gt;&gt;&gt; s = ['a', 'b', 'c', 'd', 'e', 'f']  </li><li>&gt;&gt;&gt; s[0 : len(s)] ## output: ['a', 'b', 'c', 'd', 'e', 'f']   </li><li>&gt;&gt;&gt; s[0 : -1]     ## output: ['a', 'b', 'c', 'd', 'e']  </li><li>&gt;&gt;&gt; s[ : -1]      ## output: ['a', 'b', 'c', 'd', 'e']   </li><li>&gt;&gt;&gt; s[2 : -1]     ## output: ['c', 'd', 'e']  </li><li>&gt;&gt;&gt; s[-3 : -1]    ## output: ['d', 'e']  </li><li>&gt;&gt;&gt; s[-3 : ]      ## output: ['d', 'e', 'f']  </li><li>&gt;&gt;&gt; s[3 : 1]      ## output: []  </li></ol></div><p><span style="font-size:14px"><strong>3. 扩展切片（extended_slicing）</strong><br/></span><span style="font-size:14px">扩展切片语法如下：<br/></span><span style="font-size:14px">s[begin : end : stride]<br/></span><span style="font-size:14px">与简单切片语法相比，<strong>扩展切片只是增加了第3个参数</strong>，即步长参数（英文资料中通常称为&quot;stride&quot;或&quot;step&quot;）。<br/></span><span style="font-size:14px">扩展切片语法引入的&quot;stride&quot;参数是个需要特别注意的参数，因为<strong>它的正/负取值将会影响切片操作对源序列s的访问方向</strong>，而这正是本文开始那几个示例可能引起<a href="http://lib.csdn.net/base/python" style="color:#df3434; font-weight:bold;" target="_blank" title="Python知识库">python</a>新手困惑的原因。<br/></span><span style="font-size:14px">其实规则很简单，说穿不值一文钱：<br/></span><span style="font-size:14px"><span style="background-color:rgb(255,255,0)"><strong>1)</strong></span> 当stride参数为正值（positive）时，<strong>表明切片操作从左至右（即正向）访问源序列s的元素</strong>， 此时，若begin和end参数有缺省，则Python解释器默认将其设置为None。如s[0 : : 1]会被解释器当作s[0 : None : 1]，此时，end实际取值要大于其有效索引范围的上限值，以保证切片操作能访问到源序列s从begin开始的所有元素（从左向右）。<br/></span><span style="font-size:14px"><span style="background-color:rgb(255,255,0)"><strong>2)</strong></span> 当stride参数为负值（negative）时，<strong>表明切片操作从右至左（即逆向）访问源序列s的元素</strong>， 此时，若begin和end参数有缺省，则Python解释器默认将其设置为None。如s[-1 : : -1]会被解释器当作s[-1 : None : -1]，此时，end实际取值要小于其有效索引范围的下限值，已保证切片操作能访问到源序列s从begin开始的所有元素（逆向，从右向左）。<br/></span><span style="font-size:14px"><span style="background-color:rgb(255,255,0)"><strong>3)</strong></span> 无论stride参数取正值还是负值，切片表达式的begin和end索引值需要保证在切片操作的访问方向上，从begin到end之间有元素，这样切片操作才能保证返回非空集。<br/></span><span style="font-size:14px">通过本文第2节给出的Python内部对序列对象索引值约定示意图，应该可以很容易地理解这3条规则。<br/></span><span style="font-size:14px">介绍到这里，本文开始处的那个示例输出结果的原因想必也很清楚了吧。<br/></span></p><div><div><b>[python]</b> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="view plain">view plain</a> <a href="http://blog.csdn.net/slvher/article/details/44703185#" target="_blank" title="copy">copy</a></div><ol start="1"><li>&gt;&gt;&gt; s = 'this_is_a_test'  </li><li>&gt;&gt;&gt; s[ : : -1]  </li><li>'tset_a_si_siht'  ## Q: 为何s被反转了？ A: 步长参数-1表明逆向访问s  </li><li>&gt;&gt;&gt; s[1 : 6 : -1]  </li><li>''  ## Q: 为何只得到个空串？ A: 步长参数为负时，逆向访问，但begin与end间无元素，故返空串  </li><li>&gt;&gt;&gt; s[6 : 1 : -1]    </li><li>'si_si'  ## Q: 为何是这个结果？ A: 逆向访问，切片访问到的元素正值索引范围为[2:6]，故返'si_si'  </li></ol></div><p><span style="font-size:14px"><strong>备注：</strong></span><span style="font-size:14px">根 据《Python核心编程》一书第6.1.2节的介绍，这里称为“扩展”是因为早期的Python解释器只支持不带步长参数的简单切片，带步长的切片操作 是以Python扩展的方式实现的。事实上，目前的CPython解释器早就支持纯Python的带步长参数的切片操作，但作为历史名称，“扩展”一词被 保留下来。</span><br/></p><span style="font-size:14px">【参考资料】<br/>
1. Python Docs: <a href="https://docs.python.org/2/reference/expressions.html#slicings" target="_blank">slicings</a>  <br/>
2. Python Docs: An Informal Introduction to Python - <a href="https://docs.python.org/2/tutorial/introduction.html#strings" target="_blank">strings</a> <br/>
3. Section 6.1.2 &amp; 6.3.2 of &lt;Core Python Programming&gt;，即《Python核心编程》一书第6.1.2节和6.3.2节<br/></span><span style="font-size:14px">4. StackOverflow:</span> <a href="http://stackoverflow.com/questions/509211/explain-pythons-slice-notation" style="font-size:14px" target="_blank">Explain Python's slice notation</a><span style="font-size:14px"> </span></div><div><br/></div><div><span style="font-size:14px">========================= EOF ======================</span></div></span>
</div></body></html> 